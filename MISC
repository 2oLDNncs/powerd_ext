Function %Collection%(obj, coll)
   '  Compute a list of objects from the object <obj>
   ' and fill the collection <coll> with it

   Dim MyModel
   Set MyModel=ActiveModel

   Dim t
   For each t in MyModel.ExtendedObjects
      If "Param" = t.Stereotype Then
         Dim tbl
         Set tbl = t.GetExtendedAttribute("Table")
         
         If not tbl is nothing Then
            If obj.Name = tbl.Name Then
               coll.Add(t)
            End If
         End If
      End If
   Next

   %Collection% = True
   
End Function

/**
 * @author 2oLDNncs 20241214
 */
public class XSSFWorkbookToGraphviz {
	
	static final String ARG_IN = "-In";
	static final String ARG_ARCS = "-Arcs";
	static final String ARG_NODE_PROPS = "-NodeProps";
	static final String ARG_ARC_PROPS = "-ArcProps";
	static final String ARG_OUT = "-Out";
	
	public static final void main(final String[] args) throws InvalidFormatException, IOException {
		final var ap = new ArgsParser();
		
		ap.set(ARG_IN, "data/test_gv.xlsx");
		ap.set(ARG_ARCS, "Arcs");
		ap.set(ARG_NODE_PROPS, "Node Props");
		ap.set(ARG_ARC_PROPS, "Arc Props");
		ap.set(ARG_OUT, "data/test_gv.gv");
		
		ap.parse(args);
		
		if (!ap.getString(ARG_OUT).isBlank()) {
			try (final var out = new PrintStream(ap.getFile(ARG_OUT))) {
				process(ap, out);
			}
		} else {
			process(ap, System.out);
		}
	}
	
	private static final void process(final ArgsParser ap, final PrintStream out) throws IOException, InvalidFormatException {
		try (final var workbook = new XSSFWorkbook(ap.getFile(ARG_IN))) {
			final var gvp = new GraphvizPrinter(out);
			
			gvp.begin(true);
			
			if (!ap.getString(ARG_ARCS).isEmpty()) {
				forEachLine(workbook.getSheet(ap.getString(ARG_ARCS)), gvp::processArc);
			}
			
			if (!ap.getString(ARG_NODE_PROPS).isEmpty()) {
				forEachLine(workbook.getSheet(ap.getString(ARG_NODE_PROPS)), gvp::processNodeProp);
			}
			
			if (!ap.getString(ARG_ARC_PROPS).isEmpty()) {
				forEachLine(workbook.getSheet(ap.getString(ARG_ARC_PROPS)), gvp::processArcProp);
			}
			
			gvp.end();
		}
	}
	
	public static final void forEachLine(final XSSFSheet sheet, final Consumer<String[]> action) {
		final var rowRange = new IntRange();
		final var colRange = new IntRange();
		
		if (!sheet.getTables().isEmpty()) {
			final var table = sheet.getTables().get(0);
			rowRange.addRange(table.getStartRowIndex() + table.getHeaderRowCount(), table.getEndRowIndex());
			colRange.addRange(table.getStartColIndex(), table.getEndColIndex());
		} else {
			for (final var row : sheet) {
				final var cellIterator = row.cellIterator();
				
				rowRange.addValue(row.getRowNum());
				
				while (cellIterator.hasNext()) {
					final var cell = cellIterator.next();
					colRange.addValue(cell.getColumnIndex());
				}
			}
		}
		
		if (rowRange.isEmpty() || colRange.isEmpty()) {
			return;
		}
		
		final var lineElements = new String[colRange.getSize()];
		
		for (var i = rowRange.getMin(); i <= rowRange.getMax(); i += 1) {
			final var row = sheet.getRow(i);
			
			Arrays.fill(lineElements, "");
			
			for (var j = colRange.getMin(); j <= colRange.getMax(); j += 1) {
				lineElements[j - colRange.getMin()] = toString(row.getCell(j));
			}
			
			action.accept(lineElements);
		}
	}
	
	public static final String toString(final Cell cell) {
		if (null == cell) {
			return "";
		}
		
		if (CellType.FORMULA.equals(cell.getCellType())) {
			switch (cell.getCachedFormulaResultType()) {
			case NUMERIC:
				return String.format("%s", cell.getNumericCellValue());
			case STRING:
				return String.format("%s", cell.getStringCellValue());
			case BOOLEAN:
				return String.format("%s", cell.getBooleanCellValue());
			case ERROR:
				return String.format("%s", FormulaError.forInt(cell.getErrorCellValue()).getString());
			default:
				break;
			}
		}
		
		return cell.toString();
	}
	
	/**
	 * @author 2oLDNncs 20241215
	 */
	private static final class IntRange {
		
		private int min = Integer.MAX_VALUE;
		
		private int max = Integer.MIN_VALUE;
		
		public final void addValue(final int value) {
			if (value < this.min) {
				this.min = value;
			}
			
			if (this.max < value) {
				this.max = value;
			}
		}
		
		public final void addRange(final int min, final int max) {
			if (min <= max) {
				this.addValue(min);
				this.addValue(max);
			}
		}
		
		public final int getMin() {
			return this.min;
		}
		
		public final int getMax() {
			return this.max;
		}
		
		public final int getSize() {
			final var result = 1L + this.getMax() - this.getMin();
			
			if (result < 0L || Integer.MAX_VALUE < result) {
				throw new ArithmeticException(String.format("Invalid range: %s", this));
			}
			
			return (int) result;
		}
		
		public final boolean isEmpty() {
			return this.getMax() < this.getMin();
		}
		
		@Override
		public final String toString() {
			return "IntRange [min=" + this.min + ", max=" + this.max + "]";
		}
		
	}
	
}

/**
 * @author 2oLDNncs 20240608
 *
 * @param <V>
 */
public final class OrientedGraph<V> implements Serializable {
	
	private final Map<V, Collection<V>> tailHeads = newMap();
	
	private final Map<V, Collection<V>> headTails = newMap();
	
	private final boolean transitive;
	
	public OrientedGraph(final boolean transitive) {
		this.transitive = transitive;
	}
	
	public final boolean isTransitive() {
		return this.transitive;
	}
	
	public final void connect(final V tail, final V head) {
		this.addArc(tail, head);
		
		if (this.isTransitive()) {
			this.applyTransitivity(tail, head);
		}
	}
	
	public final Collection<V> getHeads(final V tail) {
		return this.tailHeads.getOrDefault(tail, Collections.emptySet());
	}
	
	public final Collection<V> getTails(final V head) {
		return this.headTails.getOrDefault(head, Collections.emptySet());
	}
	
	public final boolean isArc(final V tail, final V head) {
		return this.getHeads(tail).contains(head);
	}
	
	public final Collection<V> getAllTails() {
		return this.tailHeads.keySet();
	}
	
	public final Collection<V> getAllHeads() {
		return this.headTails.keySet();
	}
	
	public final Collection<V> getVertices() {
		return plus(this.getAllTails(), this.getAllHeads());
	}
	
	public final Collection<V> getRoots() {
		return minus(this.getAllTails(), this.getAllHeads());
	}
	
	public final Collection<V> getLeaves() {
		return minus(this.getAllHeads(), this.getAllTails());
	}
	
	public final void forEachArc(final BiConsumer<V, V> action) {
		newMap(this.tailHeads).forEach((tail, heads) -> {
			newList(heads).forEach(head -> {
				action.accept(tail, head);
			});
		});
	}
	
	public final void forEachMaxArc(final BiConsumer<V, V> action) {
		final var leaves = this.getLeaves();
		
		this.getRoots().forEach(root -> {
			this.getHeads(root).stream()
			.filter(leaves::contains)
			.forEach(leaf -> {
				action.accept(root, leaf);
			});
		});
	}
	
	public final void forEachMaxPath(final Consumer<List<V>> action) {
		this.getRoots().forEach(root -> {
			this.forEachPathFrom(root, action);
		});
	}
	
	public final void forEachPathFrom(final V head, final Consumer<List<V>> action) {
		this.new OutgoingPathFinder().forEachPath(head, action);
	}
	
	public final void forEachPathTo(final V tail, final Consumer<List<V>> action) {
		this.new IncomingPathFinder().forEachPath(tail, action);
	}
	
	private final void addArc(final V tail, final V head) {
		add(this.tailHeads, tail, head);
		add(this.headTails, head, tail);
	}
	
	private final void applyTransitivity(final V tail, final V head) {
		final var predecessors = newList(this.getTails(tail));
		final var successors = newList(this.getHeads(head));
		
		predecessors.forEach(p -> {
			this.addArc(p, head);
		});
		
		successors.forEach(s -> {
			this.addArc(tail, s);
		});
		
		predecessors.forEach(p -> {
			successors.forEach(s -> {
				this.addArc(p, s);
			});
		});
	}
	
	/**
	 * @author 2oLDNncs 20240621
	 */
	private final class OutgoingPathFinder extends PathFinder<V> {
		
		public OutgoingPathFinder() {
			super(OrientedGraph.this.getLeaves());
		}
		
		@Override
		protected final Object[] getCycleExceptionMessageArgs(final Object path, final Object vertex) {
			return new Object[] { path, vertex };
		}
		
		@Override
		protected final Collection<V> getNextVertices(V origin) {
			return OrientedGraph.this.getHeads(origin);
		}
		
		@Override
		protected final int getInsertionIndex(final int pathSize) {
			return pathSize;
		}
		
		@Override
		protected final int getRemovalIndex(final int pathSize) {
			return pathSize - 1;
		}
		
		private static final long serialVersionUID = -2004507300852730885L;
		
	}
	
	/**
	 * @author 2oLDNncs 20240621
	 */
	private final class IncomingPathFinder extends PathFinder<V> {
		
		public IncomingPathFinder() {
			super(OrientedGraph.this.getRoots());
		}
		
		@Override
		protected final Object[] getCycleExceptionMessageArgs(final Object path, final Object vertex) {
			return new Object[] { vertex, path };
		}
		
		@Override
		protected final Collection<V> getNextVertices(V origin) {
			return OrientedGraph.this.getTails(origin);
		}
		
		@Override
		protected final int getInsertionIndex(final int pathSize) {
			return 0;
		}
		
		@Override
		protected final int getRemovalIndex(final int pathSize) {
			return 0;
		}
		
		private static final long serialVersionUID = -1342815930328295026L;
		
	}
	
	private static final long serialVersionUID = 7797977345376468869L;
	
	private static final <K, V> boolean add(final Map<K, Collection<V>> arcs, final K tail, final V head) {
		return arcs.computeIfAbsent(tail, __ -> newSet()).add(head);
	}
	
	private static final <E> Collection<E> binop(final BiConsumer<Collection<E>, Collection<E>> op,
			final Collection<E> a, final Collection<E> b) {
		final var result = newSet(a);
		
		op.accept(result, b);
		
		return result;
	}
	
	private static final <E> Collection<E> plus(final Collection<E> a, final Collection<E> b) {
		return binop(Collection::addAll, a, b);
	}
	
	private static final <E> Collection<E> minus(final Collection<E> a, final Collection<E> b) {
		return binop(Collection::removeAll, a, b);
	}
	
	private static final <E> List<E> newList() {
		return new ArrayList<>();
	}
	
	private static final <E> List<E> newList(final Collection<E> source) {
		return new ArrayList<>(source);
	}
	
	private static final <K, V> Map<K, V> newMap() {
		return new HashMap<>();
	}
	
	private static final <K, V> Map<K, V> newMap(final Map<K, V> source) {
		return new HashMap<>(source);
	}
	
	private static final <E> Collection<E> newSet() {
		return new HashSet<>();
	}
	
	private static final <E> Collection<E> newSet(final Collection<E> source) {
		return new HashSet<>(source);
	}
	
	/**
	 * @author 2oLDNncs 20240621
	 *
	 * @param <V>
	 */
	private static abstract class PathFinder<V> implements Serializable {
		
		private final List<V> path = newList();
		
		private final Collection<V> ends;
		
		protected PathFinder(final Collection<V> ends) {
			this.ends = ends;
		}
		
		public final void forEachPath(final V anchor, final Consumer<List<V>> action) {
			this.begin(anchor);
			
			this.getNextVertices(anchor).forEach(v -> {
				this.forEachPath(v, action);
			});
			
			this.end(action);
		}
		
		protected abstract Object[] getCycleExceptionMessageArgs(Object path, Object vertex);
		
		protected abstract Collection<V> getNextVertices(V origin);
		
		protected abstract int getInsertionIndex(int pathSize);
		
		protected abstract int getRemovalIndex(int pathSize);
		
		private final void begin(final V vertex) {
			if (this.path.contains(vertex)) {
				throw new IllegalStateException(
						String.format("Cycle detected : %s -> %s",
								this.getCycleExceptionMessageArgs(this.path, vertex)));
			}
			
			this.path.add(this.getInsertionIndex(this.path.size()), vertex);
		}
		
		private final void end(final Consumer<List<V>> action) {
			final var i = this.getRemovalIndex(this.path.size());
			final var e = this.path.get(i);
			
			if (this.ends.contains(e)) {
				action.accept(this.path);
			}
			
			this.path.remove(i);
		}
		
		private static final long serialVersionUID = -2445477282075393002L;
		
	}
	
}

/**
 * @author 2oLDNncs 20240804
 */
public final class GraphvizPrinter {
	
	private final PrintStream out;
	
	private final Map<List<String>, Map<String, String>> nodeProps = new LinkedHashMap<>();
	private final Map<List<Integer>, Map<String, String>> arcProps = new LinkedHashMap<>();
	private final Map<List<String>, Integer> nodeIds = new LinkedHashMap<>();
	private final Map<String, Object> clusters = new LinkedHashMap<>();
	private final Collection<List<Integer>> arcs = new ArrayList<>();
	
	private int expectedArcElementsLength = -1;
	private int nodePropLineNumber = 1;
	private int arcPropLineNumber = 1;
	private int arcLineNumber = 1;
	
	public GraphvizPrinter(final PrintStream out) {
		this.out = out;
	}
	
	public final void begin(final boolean isStrict) {
		this.out.println(String.format("%sdigraph G { // Use strict to merge duplicate edges", isStrict ? "strict " : ""));
		this.out.println("	layout=dot // Use dot for clustering");
		this.out.println("	compound=true // If true, allow edges between clusters");
		this.out.println("	rankdir=TB // TB or LR");
	}
	
	/**
	 * @param nodePropElements an array of length N+2:
	 * [nodeParts[0], ..., nodeParts[N-1], propKey, propVal]
	 */
	public final void processNodeProp(final String... nodePropElements) {
		final var node = this.toNode(String.format("Node prop line %s", this.nodePropLineNumber),
				Arrays.copyOf(nodePropElements, nodePropElements.length - 2));
		final var propKey = nodePropElements[nodePropElements.length - 2];
		final var propVal = nodePropElements[nodePropElements.length - 1];
		
		this.nodeProps.computeIfAbsent(node, __ -> new LinkedHashMap<>()).put(propKey, propVal);
		
		this.nodePropLineNumber += 1;
	}
	
	/**
	 * @param arcPropElements an array of length 2*N+2:
	 * [tailNodeParts[0], ..., tailNodeParts[N-1], headNodeParts[0], ..., headNodeParts[N-1], propKey, propVal]
	 */
	public final void processArcProp(final String... arcPropElements) {
		final var arc = this.toArc(String.format("Arc prop line %s", this.arcPropLineNumber),
				Arrays.copyOf(arcPropElements, arcPropElements.length - 2));
		final var propKey = arcPropElements[arcPropElements.length - 2];
		final var propVal = arcPropElements[arcPropElements.length - 1];
		
		this.arcProps.computeIfAbsent(arc, __ -> new LinkedHashMap<>()).put(propKey, propVal);
		
		this.arcPropLineNumber += 1;
	}
	
	/**
	 * @param arcElements an array of length 2*N:
	 * [tailNodeParts[0], ..., tailNodeParts[N-1], headNodeParts[0], ..., headNodeParts[N-1]]
	 */
	public final void processArc(final String... arcElements) {
		this.arcs.add(this.toArc(String.format("Arc line %s", this.arcLineNumber), arcElements));
		
		this.arcLineNumber += 1;
	}
	
	private final void printArcs() {
		this.arcs.forEach(arc -> {
			final var tailId = arc.get(0);
			final var headId = arc.get(1);
			// It is possible to use ltail and lhead all the time
			// When the node is an actual cluster node, Graphviz will clip the edges appropriately
			// Otherwise, the nodes are connected as usual
			this.out.println(String.format("	%s -> %s [ltail=cluster_%s,lhead=cluster_%s,%s]",
					tailId, headId, tailId, headId,
					formatProps(this.arcProps.getOrDefault(arc, Collections.emptyMap()))));
		});
	}
	
	public final void end() {
		this.printArcs();
		this.printClusters();
		
		this.out.println("}");
	}
	
	private final List<String> toNode(final String context, final String[] nodeElements) {
		if (this.expectedArcElementsLength < 0) {
			this.expectedArcElementsLength = 2 * nodeElements.length;
		}
		
		if (this.expectedArcElementsLength / 2 != nodeElements.length) {
			throw new IllegalArgumentException(String.format("%s: Wrong number of elements (expected: %s, actual: %s)",
					context,
					this.expectedArcElementsLength / 2,
					nodeElements.length));
		}
		
		return Arrays.asList(nodeElements);
	}
	
	private final List<Integer> toArc(final String context, final String[] arcElements) {
		if (0 != (arcElements.length & 1)) {
			throw new IllegalArgumentException(String.format("%s: Odd number of elements", context));
		}
		
		if (this.expectedArcElementsLength < 0) {
			this.expectedArcElementsLength = arcElements.length;
		}
		
		if (this.expectedArcElementsLength != arcElements.length) {
			throw new IllegalArgumentException(String.format("%s: Wrong number of elements (expected: %s, actual: %s)",
					context, this.expectedArcElementsLength, arcElements.length));
		}
		
		final var tail = Arrays.asList(Arrays.copyOfRange(arcElements, 0, arcElements.length / 2));
		final var head = Arrays.asList(Arrays.copyOfRange(arcElements, arcElements.length / 2, arcElements.length));
		
		this.updateNodeIds(tail);
		this.updateNodeIds(head);
		
		this.updateClusters(tail);
		this.updateClusters(head);
		
		final var tailId = this.nodeIds.get(tail);
		final var headId = this.nodeIds.get(head);
		
		return Arrays.asList(tailId, headId);
	}
	
	private final void updateNodeIds(final List<String> node) {
		for (var i = 0; i < node.size(); i += 1) {
			this.nodeIds.computeIfAbsent(keepLeft(node, i, FILLER), __ -> 1 + this.nodeIds.size());
		}
	}
	
	private final void printClusters() {
		final var node = new ArrayList<>(Collections.nCopies(this.expectedArcElementsLength / 2, FILLER));
		
		this.printClusters(this.clusters, node, 0, "\t");
	}
	
	private final void printClusters(final Map<String, Object> clusters,
			final List<String> node, final int i, final String indent) {
		clusters.forEach((k, v) -> {
			node.set(i, k);
			final var nodeId = Objects.requireNonNull(this.nodeIds.get(node));
			final var nodeProps = new LinkedHashMap<>(Map.of("label", k));
			
			nodeProps.putAll(this.nodeProps.getOrDefault(node, Collections.emptyMap()));
			
			if (i + 1 < node.size()) {
				// Graphviz doc: Clusters are encoded as subgraphs whose names have the prefix 'cluster'.
				this.out.println(String.format("%ssubgraph cluster_%s {", indent, nodeId));
				
				nodeProps.forEach((propK, propV) -> {
					this.out.println(String.format("%s	%s=\"%s\"", indent, propK, propV));
				});
				
				// This is a trick to get a node that can be used to connect to/from the whole cluster using ltail and lhead
				// FIXME This invisible node actually gets positioned next to the visible ones (instead of above),
				//       so the incoming and outgoing edges aren't aimed at the center : how to fix this?
				//       We can add invisible edges from the invisible cluster node to force its rank,
				//       but the result looks weird (hard to describe, the invisible nodes affect the global layout)
				this.out.println(String.format("%s	%s [label=\"\",shape=point,width=0,height=0]", indent, nodeId));
				
				this.printClusters((Map) v, node, i + 1, indent + "\t");
				
				this.out.println(String.format("%s}", indent));
			} else if (!"".equals(k)) { // To avoid duplicates, don't print an additional node if the leaf matches a cluster node
				this.out.println(String.format("%s%s [%s]",
						indent, nodeId, formatProps(nodeProps)));
			}
			
			node.set(i, FILLER);
		});
	}
	
	private final void updateClusters(final List<String> node) {
		var c = this.clusters;
		
		for (var i = 0; i + 1 < node.size(); i += 1) {
			c = (Map) c.computeIfAbsent(node.get(i), __ -> new LinkedHashMap<>());
		}
		
		c.put(node.get(node.size() - 1), null);
	}
	
	private static final String FILLER = "";
	
	private static final <E> List<E> keepLeft(final List<E> elements, final int n, final E filler) {
		final var result = new ArrayList<>(elements);
		
		Collections.fill(result.subList(n + 1, result.size()), filler);
		
		return result;
	}
	
	private static final String formatProps(final Map<String, String> props) {
		return String.join(",", props.entrySet().stream()
				.map(e -> String.format("%s=\"%s\"", e.getKey(), e.getValue()))
				.toArray(String[]::new));
	}
	
}

/**
 * @author 2oLDNncs 20240828
 */
public final class Indices extends AbstractList<int[]> {
	
	private final int[] dims;
	
	private final int size;
	
	public Indices(final int... dims) {
		this.dims = dims;
		
		if (0 == dims.length) {
			this.size = 0;
		} else {
			long n = 1L;
			
			for (final var i : dims) {
				if (i < 0) {
					throw new IllegalArgumentException(String.format("%s < 0", i));
				}
				
				n = Objects.checkIndex(n * i, Integer.MAX_VALUE + 1L);
			}
			
			this.size = (int) n;
		}
	}
	
	public final int[] getDims() {
		return this.dims;
	}
	
	public final int toIndex(final int[] values) {
		this.checkLength(values);
		
		var result = 0;
		var dim = 1;
		
		for (var i = this.getDims().length - 1; 0 <= i ; i -= 1) {
			result += values[i] * dim;
			dim *= this.getDims()[i];
		}
		
		return result;
	}
	
	public final int[] fromIndex(final int index, final int[] values) {
		Objects.checkIndex(index, this.size());
		this.checkLength(values);
		
		if (0 == index) {
			Arrays.fill(values, 0, this.getDims().length, 0);
		} else {
			var n = index;
			
			for (var i = this.getDims().length - 1; 0 <= i; i -= 1) {
				values[i] = n % this.getDims()[i];
				n /= this.getDims()[i];
			}
		}
		
		return values;
	}
	
	@Override
	public final int[] get(final int index) {
		return this.fromIndex(index, new int[this.getDims().length]);
	}
	
	@Override
	public final int size() {
		return this.size;
	}
	
	@Override
	public final Iterator<int[]> iterator() {
		return new Iterator<>() {
			
			private final int[] values = new int[getDims().length];
			
			{
				if (0 < this.values.length) {
					this.values[this.values.length - 1] = -1;
				}
			}
			
			@Override
			public final int[] next() {
				return this.values;
			}
			
			@Override
			public final boolean hasNext() {
				return nextIndices(getDims(), this.values);
			}
			
		};
	}
	
	private final void checkLength(final int[] values) {
		if (this.getDims().length != values.length) {
			throw new IllegalArgumentException(String.format("Invalid length (expected: %s, actual: %s)",
					this.getDims().length, values.length));
		}
	}
	
	public static final boolean nextIndices(final int[] dims, final int[] values) {
		for (var i = dims.length - 1; 0 <= i; i -= 1) {
			values[i] += 1;
			
			if (values[i] < dims[i]) {
				return true;
			}
			
			values[i] = 0;
		}
		
		return false;
	}
	
}


/**
 * @author 2oLDNncs 20241028
 */
public final class ArgsParser {
	
	private final Map<String, Object> map = new HashMap<>();
	
	public final void set(final String key, final Object value) {
		this.map.put(key, value);
	}
	
	public final byte getByte(final String key) {
		return this.get(key);
	}
	
	public final char getChar(final String key) {
		return this.get(key);
	}
	
	public final short getShort(final String key) {
		return this.get(key);
	}
	
	public final int getInt(final String key) {
		return this.get(key);
	}
	
	public final long getLong(final String key) {
		return this.get(key);
	}
	
	public final double getDouble(final String key) {
		return this.get(key);
	}
	
	public final String getString(final String key) {
		return this.get(key);
	}
	
	public final File getFile(final String key) {
		return new File(this.getString(key));
	}
	
	public final Path getPath(final String key) {
		return this.getFile(key).toPath();
	}
	
	public final <E extends Enum<?>> E getEnum(final String key) {
		return this.get(key);
	}
	
	public final void parse(final String... args) {
		var keyIndex = 0;
		int keyStep;
		
		while (keyIndex < args.length) {
			final var key = args[keyIndex];
			final var defaultValue = this.get(key);
			Object value = "";
			
			if (defaultValue instanceof Boolean) {
				value = !(Boolean) defaultValue;
				keyStep = 1;
			} else {
				final var valueString = args[keyIndex + 1];
				
				if (defaultValue instanceof Byte) {
					value = Byte.parseByte(valueString);
				} else if (defaultValue instanceof Character) {
					value = Character.valueOf(valueString.charAt(0));
				} else if (defaultValue instanceof Short) {
					value = Short.parseShort(valueString);
				} else if (defaultValue instanceof Integer) {
					value = Integer.parseInt(valueString);
				} else if (defaultValue instanceof Long) {
					value = Long.parseLong(valueString);
				} else if (defaultValue instanceof Float) {
					value = Float.parseFloat(valueString);
				} else if (defaultValue instanceof Double) {
					value = Double.parseDouble(valueString);
				} else if (defaultValue instanceof Enum<?>) {
					value = parseEnum(cast(defaultValue.getClass()), valueString);
				} else {
					value = valueString;
				}
				
				keyStep = 2;
			}
			
			this.set(key, value);
			
			keyIndex += keyStep;
		}
	}
	
	private final <T> T get(final String key) {
		return cast(this.map.get(key));
	}
	
	@SuppressWarnings("unchecked")
	public static final <E extends Enum<?>> E parseEnum(final Class<E> enumClass, final String prefix) {
		try {
			for (final var enumValue : (E[]) enumClass.getMethod("values").invoke(null)) {
				if (enumValue.toString().startsWith(prefix)) {
					return enumValue;
				}
			}
		} catch (final Exception e) {
			throw new RuntimeException(e);
		}
		
		throw new IllegalArgumentException(String.format("Failed to parse %s as %s", prefix, enumClass));
	}
	
	@SuppressWarnings("unchecked")
	private static final <T> T cast(final Object object) {
		return (T) object;
	}
	
}

/**
 * @author 2oLDNncs 20241030
 */
public final class GroupReplacer implements UnaryOperator<String> {
	
	private final Pattern pattern;
	
	private final IntFunction<String> replacer;
	
	public GroupReplacer(final Pattern pattern, final IntFunction<String> replacer) {
		this.pattern = pattern;
		this.replacer = replacer;
	}
	
	@Override
	public final String apply(final String input) {
		final var matcher = this.pattern.matcher(input);
		final var result = new StringBuilder();
		var i = 0;
		
		while (matcher.find()) {
			result.append(input.substring(i, matcher.start()));
			result.append(this.replacer.apply(groupIndex(matcher)));
			i = matcher.end();
		}
		
		result.append(input.substring(i));
		
		return result.toString();
	}
	
	public static final int groupIndex(final Matcher matcher) {
		for (var i = 1; i <= matcher.groupCount(); i += 1) {
			if (null != matcher.group(i)) {
				return i;
			}
		}
		
		return 0;
	}
	
}

/**
 * @author 2oLDNncs 20241030
 */
public final class GroupReplacerBuilder {
	
	private final List<String> groups = new ArrayList<>();
	
	private final List<String> replacements = new ArrayList<>();
	
	public final void addReplacement(final String key, final String replacement) {
		final var group = String.format("(%s)", Pattern.quote(key));
		
		if (this.groups.contains(group)) {
			throw new IllegalArgumentException(String.format("Duplicate replacement key: %s", key));
		}
		
		groups.add(group);
		replacements.add(replacement);
	}
	
	public final GroupReplacer build() {
		return new GroupReplacer(
				Pattern.compile(String.join("|", this.groups)),
				i -> this.replacements.get(i - 1));
	}
	
}

/**
 * @author 2oLDNncs 20241108
 */
public final class Index {
	
	private int value;
	
	private final int step;
	
	private final int end;
	
	public Index(final int end) {
		this(1, end);
	}
	
	public Index(final int step, final int end) {
		this.step = step;
		this.end = end;
	}
	
	public final int getValue() {
		return this.value;
	}
	
	public final void setValue(final int value) {
		if (value < 0) {
			throw new IllegalArgumentException();
		}
		
		this.value = value;
	}
	
	public final int getStep() {
		return this.step;
	}
	
	public final int getEnd() {
		return this.end;
	}
	
	public final boolean isValid() {
		return this.getValue() < this.getEnd();
	}
	
	public final void incr() {
		this.incr(this.getStep());
	}
	
	public final void incr(final int delta) {
		this.setValue(this.getValue() + delta);
	}
	
	public final boolean next() {
		return this.next(this.getStep());
	}
	
	public final boolean next(final int delta) {
		this.incr(delta);
		
		if (this.getValue() < this.getEnd()) {
			return true;
		}
		
		this.setValue(0);
		
		return false;
	}
	
	public final void next(final Index iNext) {
		if (!this.next()) {
			iNext.incr();
		}
	}
	
}

/**
 * @author 2oLDNncs 20241108
 */
public final class Reshaper {
	
	private final int inputPageWidth;
	
	private final ReshaperLayout inputLayout;
	
	private final List<List<String>> data = new ArrayList<>();
	
	private final Index inputLineIndexInPage;
	
	private final Index inputPageVerticalIndex;
	
	private final Index inputPageHorizontalIndex;
	
	public Reshaper(final int inputPageWidth, final int inputPageHeight,
			final ReshaperLayout inputLayout, final int inputLayoutStride) {
		this.inputPageWidth = inputPageWidth;
		this.inputLineIndexInPage = new Index(inputPageHeight);
		this.inputLayout = inputLayout;
		this.inputPageVerticalIndex = new Index(inputLayoutStride);
		this.inputPageHorizontalIndex = new Index(inputLayoutStride);
	}
	
	private final String formatDataRowElement(final String element) {
		return String.format("%-" + this.inputPageWidth + "." + this.inputPageWidth + "s", element);
	}
	
	public static final int to1D(final Index i0, final Index i1) {
		return i1.getValue() + i0.getValue() * i1.getEnd();
	}
	
	public final void addInputLine(final String inputLine) {
		final var r = to1D(this.inputPageVerticalIndex, this.inputLineIndexInPage);
		final var c = this.inputPageHorizontalIndex.getValue();
		
		while (getDataHeight() <= r) {
			this.data.add(new ArrayList<>());
		}
		
		while (this.data.get(r).size() <= c) {
			this.data.get(r).add(this.formatDataRowElement(""));
		}
		
		this.data.get(r).set(c, this.formatDataRowElement(inputLine));
		
		if (!this.inputLineIndexInPage.next()) {
			this.inputLayout.next(this.inputPageVerticalIndex, this.inputPageHorizontalIndex);
		}
	}
	
	public final void printTo(final PrintStream out) {
		this.checkData();
		
		this.data.stream()
		.map(row -> String.join("", row))
		.forEach(out::println);
	}
	
	public final void printTo(final PrintStream out,
			final int outputPageWidth, final int outputPageHeight, final ReshaperLayout outputLayout) {
		this.checkData();
		
		final var page = this.new Page(outputPageWidth, outputPageHeight, outputLayout);
		
		while (page.isValid()) {
			page.printTo(out);
			page.next();
		}
	}
	
	final int getDataWidth() {
		return addLengths(this.data.get(0));
	}
	
	private static final int addLengths(final Collection<String> strings) {
		return strings.stream()
				.mapToInt(String::length)
				.sum();
	}
	
	final int getDataHeight() {
		return this.data.size();
	}
	
	final String getData(final int offsetV, final int offsetH, final int width) {
		return String.join("", this.data.get(offsetV)).substring(offsetH, offsetH + width);
	}
	
	private final void checkData() {
		if (!this.data.isEmpty()) {
			final var dataWidth = this.getDataWidth();
			
			for (final var row : this.data) {
				final var rowLength = addLengths(row);
				
				if (dataWidth != rowLength) {
					throw new IllegalStateException(String.format("dataWidth: %s rowLength: %s", dataWidth, rowLength));
				}
			}
		}
	}
	
	/**
	 * @author 2oLDNncs 20241108
	 */
	private final class Page {
		
		private final Index vIndex;
		
		private final Index hIndex;
		
		private final ReshaperLayout layout;
		
		Page(final int width, final int height, final ReshaperLayout layout) {
			this.vIndex = new Index(height, getDataHeight());
			this.hIndex = new Index(width, getDataWidth());
			this.layout = layout;
		}
		
		final boolean isValid() {
			return this.vIndex.isValid() && this.hIndex.isValid();
		}
		
		final void next() {
			this.layout.next(this.vIndex, this.hIndex);
		}
		
		final void printTo(final PrintStream out) {
			for (var k = 0; k < this.vIndex.getStep(); k += 1) {
				out.println(getData(this.vIndex.getValue() + k, this.hIndex.getValue(), this.hIndex.getStep()));
			}
		}
		
	}
	
}

/**
 * @author 2oLDNncs 20241108
 */
public enum ReshaperLayout {
	
	HORIZONTAL {
		
		@Override
		public final void next(final Index vIndex, final Index hIndex) {
			hIndex.next(vIndex);
		}
		
	}, VERTICAL {
		
		@Override
		public final void next(final Index vIndex, final Index hIndex) {
			vIndex.next(hIndex);
		}
		
	};
	
	public abstract void next(Index vIndex, Index hIndex);
	
}

function main(workbook: ExcelScript.Workbook) {
	let selectedSheet = workbook.getActiveWorksheet();

	selectedSheet.getShapes().forEach(shape => {
		if ("{F9536926-BCBA-42FC-8F89-698BED5BE012}" != shape.getAltTextDescription()) {
			shape.delete();
		}
	});

	let heads = new Map<string, [string]>();
	let tails = new Map<string, [string]>();

	let usedRange = selectedSheet.getUsedRange();

	console.log("usedRange");

	for (let j = 1; j < usedRange.getRowCount(); j += 1) {
		let rowTexts = usedRange.getRow(j).getTexts()[0];
		let head = rowTexts[0];
		let tail = rowTexts[1];

		console.log(head + " -> " + tail);

		if (heads.has(tail)) {
			heads.get(tail).push(head);
		} else {
			heads.set(tail, [head]);
		}
		
		if (tails.has(head)) {
			tails.get(head).push(tail);
		} else {
			tails.set(head, [tail]);
		}
	}

	console.log("heads");
	console.log(heads);

	console.log("tails");
	console.log(tails);

	let nodes = new Set<string>();

	heads.forEach((hs, t) => {
		nodes.add(t);
	});

	tails.forEach((ts, h) => {
		nodes.add(h);
	});

	console.log("nodes");
	console.log(nodes);

	const depth = (node: string) => {
		let result = 0;
		let hs = new Set(heads.get(node) ?? []);

		while (0 < hs.size) {
			result += 1;

			let tmp = new Set<string>();
			hs.forEach(h => {
				(heads.get(h) ?? []).forEach(e => {
					tmp.add(e);
				});
			});
			hs = tmp;
		}

		return result;
	};

	let offsets: number[] = [];
	let nodeShapes = new Map < string, ExcelScript.Shape >();
	let nodes_ = Array.from(nodes.values());

// This needs to be a for loop because Excel seems to execute a forEach in non-sequential way
	for (let i = 0; i < nodes.size; i += 1) {
		const node = nodes_[i];
		const d = depth(node);

		while (offsets.length <= d) {
			offsets.push(-1);
		}

		offsets[d] += 1;

		let nodeShape = selectedSheet.addGeometricShape(ExcelScript.GeometricShapeType.rectangle);
		nodeShape.setPlacement(ExcelScript.Placement.absolute);
		nodeShape.setLeft(200 + d * 150);
		nodeShape.setTop(100 + offsets[d] * 30);
		nodeShape.getTextFrame().getTextRange().setText(node);
		nodeShape.getTextFrame().setAutoSizeSetting(ExcelScript.ShapeAutoSize.autoSizeShapeToFitText);
		nodeShapes.set(node, nodeShape);
	}

	for (let j = 1; j < usedRange.getRowCount(); j += 1) {
		const rowTexts = usedRange.getRow(j).getTexts()[0];
		const head = rowTexts[0];
		const tail = rowTexts[1];
		let headShape = nodeShapes.get(head);
		let tailShape = nodeShapes.get(tail);
		let line_13 = selectedSheet.addLine(0, 0, 100, 100).getLine();
		line_13.connectBeginShape(headShape, 3);
		line_13.connectEndShape(tailShape, 1);
	}
}
