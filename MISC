Function %Collection%(obj, coll)
   '  Compute a list of objects from the object <obj>
   ' and fill the collection <coll> with it

   Dim MyModel
   Set MyModel=ActiveModel

   Dim t
   For each t in MyModel.ExtendedObjects
      If "Param" = t.Stereotype Then
         Dim tbl
         Set tbl = t.GetExtendedAttribute("Table")
         
         If not tbl is nothing Then
            If obj.Name = tbl.Name Then
               coll.Add(t)
            End If
         End If
      End If
   Next

   %Collection% = True
   
End Function

/**
 * @author 2oLDNncs 20240608
 *
 * @param <V>
 */
public final class OrientedGraph<V> implements Serializable {
	
	private final Map<V, Collection<V>> headTails = newMap();
	
	private final Map<V, Collection<V>> tailHeads = newMap();
	
	private final boolean transitive;
	
	public OrientedGraph(final boolean transitive) {
		this.transitive = transitive;
	}
	
	public final boolean isTransitive() {
		return this.transitive;
	}
	
	public final void connect(final V head, final V tail) {
		this.addArc(head, tail);
		
		if (this.isTransitive()) {
			this.applyTransitivity(head, tail);
		}
	}
	
	public final Collection<V> getTails(final V head) {
		return this.headTails.getOrDefault(head, Collections.emptySet());
	}
	
	public final Collection<V> getHeads(final V tail) {
		return this.tailHeads.getOrDefault(tail, Collections.emptySet());
	}
	
	public final boolean isArc(final V head, final V tail) {
		return this.getTails(head).contains(tail);
	}
	
	public final Collection<V> getAllHeads() {
		return this.headTails.keySet();
	}
	
	public final Collection<V> getAllTails() {
		return this.tailHeads.keySet();
	}
	
	public final Collection<V> getVertices() {
		return plus(this.getAllHeads(), this.getAllTails());
	}
	
	public final Collection<V> getRoots() {
		return minus(this.getAllHeads(), this.getAllTails());
	}
	
	public final Collection<V> getLeaves() {
		return minus(this.getAllTails(), this.getAllHeads());
	}
	
	public final void forEachArc(final BiConsumer<V, V> action) {
		newMap(this.headTails).forEach((head, tails) -> {
			newList(tails).forEach(tail -> {
				action.accept(head, tail);
			});
		});
	}
	
	public final void forEachMaxArc(final BiConsumer<V, V> action) {
		final var leaves = this.getLeaves();
		
		this.getRoots().forEach(root -> {
			this.getTails(root).stream()
			.filter(leaves::contains)
			.forEach(leaf -> {
				action.accept(root, leaf);
			});
		});
	}
	
	public final void forEachMaxPath(final Consumer<List<V>> action) {
		this.getRoots().forEach(root -> {
			this.forEachPathFrom(root, action);
		});
	}
	
	public final void forEachPathFrom(final V head, final Consumer<List<V>> action) {
		final var path = OrientedGraph.<V>newList();
		final var leaves = this.getLeaves();
		
		path.add(head);
		
		this.walkFrom(head, new Walker<V>() {
			
			@Override
			public final void begin(final V vertex) {
				if (path.contains(vertex)) {
					throw new IllegalStateException(
							String.format("Cycle detected : %s -> %s", path, vertex));
				}
				
				path.add(vertex);
			}
			
			@Override
			public final void end() {
				final var i = path.size() - 1;
				final var e = path.get(i);
				
				if (leaves.contains(e)) {
					action.accept(path);
				}
				
				path.remove(i);
			}
			
			private static final long serialVersionUID = -6817842935026693707L;
			
		});
	}
	
	public final void forEachPathTo(final V tail, final Consumer<List<V>> action) {
		final var path = OrientedGraph.<V>newList();
		final var roots = this.getRoots();
		
		path.add(tail);
		
		this.walkTo(tail, new Walker<V>() {
			
			@Override
			public final void begin(final V vertex) {
				if (path.contains(vertex)) {
					throw new IllegalStateException(
							String.format("Cycle detected : %s -> %s", vertex, path));
				}
				
				path.add(0, vertex);
			}
			
			@Override
			public final void end() {
				final var i = 0;
				final var e = path.get(i);
				
				if (roots.contains(e)) {
					action.accept(path);
				}
				
				path.remove(i);
			}
			
			private static final long serialVersionUID = 4874395443803361650L;
			
		});
	}
	
	private final void walkFrom(final V head, final Walker<V> walker) {
		this.getTails(head).forEach(tail -> {
			walker.begin(tail);
			this.walkFrom(tail, walker);
			walker.end();
		});
	}
	
	private final void walkTo(final V tail, final Walker<V> walker) {
		this.getHeads(tail).forEach(head -> {
			walker.begin(head);
			this.walkTo(head, walker);
			walker.end();
		});
	}
	
	private final void addArc(final V head, final V tail) {
		add(this.headTails, head, tail);
		add(this.tailHeads, tail, head);
	}
	
	private final void applyTransitivity(final V head, final V tail) {
		final var predecessors = newList(this.getHeads(head));
		final var successors = newList(this.getTails(tail));
		
		predecessors.forEach(p -> {
			this.addArc(p, tail);
		});
		
		successors.forEach(s -> {
			this.addArc(head, s);
		});
		
		predecessors.forEach(p -> {
			successors.forEach(s -> {
				this.addArc(p, s);
			});
		});
	}
	
	private static final long serialVersionUID = 7797977345376468869L;
	
	private static final <K, V> boolean add(final Map<K, Collection<V>> arcs, final K head, final V tail) {
		return arcs.computeIfAbsent(head, __ -> newSet()).add(tail);
	}
	
	private static final <E> Collection<E> binop(final BiConsumer<Collection<E>, Collection<E>> op,
			final Collection<E> a, final Collection<E> b) {
		final var result = newSet(a);
		
		op.accept(result, b);
		
		return result;
	}
	
	private static final <E> Collection<E> plus(final Collection<E> a, final Collection<E> b) {
		return binop(Collection::addAll, a, b);
	}
	
	private static final <E> Collection<E> minus(final Collection<E> a, final Collection<E> b) {
		return binop(Collection::removeAll, a, b);
	}
	
	private static final <E> List<E> newList() {
		return new ArrayList<>();
	}
	
	private static final <E> List<E> newList(final Collection<E> source) {
		return new ArrayList<>(source);
	}
	
	private static final <K, V> Map<K, V> newMap() {
		return new HashMap<>();
	}
	
	private static final <K, V> Map<K, V> newMap(final Map<K, V> source) {
		return new HashMap<>(source);
	}
	
	private static final <E> Collection<E> newSet() {
		return new HashSet<>();
	}
	
	private static final <E> Collection<E> newSet(final Collection<E> source) {
		return new HashSet<>(source);
	}
	
	/**
	 * @author 2oLDNncs 20240619
	 *
	 * @param <V>
	 */
	private static abstract interface Walker<V> extends Serializable {
		
		public abstract void begin(V vertex);
		
		public abstract void end();
		
	}
	
}
